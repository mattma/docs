
Pointers are a way of sharing data across functions and goroutines.

Pointers reference a location in memory where a value
is stored rather than the value itself.

```go
func zero(xPtr *int) {
*xPtr = 0
}
func main() {
x := 5
zero(&x)
fmt.Println(x) // x is 0
}
```

In Go a pointer is represented using the * (asterisk)
character followed by the type of the stored value.
* is also used to “dereference” pointer variables. Dereferencing
a pointer gives us access to the value the
pointer points to.

we use the & operator to find the address of a variable. &x returns a *int (pointer to an int) because x
is an int. This is what allows us to modify the original
variable. &x in main and xPtr in zero refer to the same
memory location.


- new

new takes a type as an argument, allocates enough
memory to fit a value of that type and returns a
pointer to it.
Another way to get a pointer is to use the built-in new
function:

```go
func one(xPtr *int) {
*xPtr = 1
}
func main() {
xPtr := new(int)
one(xPtr)
fmt.Println(*xPtr) // x is 1
}
```

#### Pointers

Go has pointers, but no pointer arithmetic. Struct fields can be accessed through a struct pointer. Can call fields and methods on a pointer.

By default, Go passes augruments by value (copying the arguments), if pass the argument by reference, pass pointers or use a structure using reference values like slices and maps.

To get the pointer of a value, use the **&** symbol in front of the value, to dereference a pointer, use `*`.

Methods are often defined on pointers and not values, although they can be defined on both, often store a pointer in a variable.


#### Gotcha

1. There is no pointer arithmetic. You cannot write in Go

you cannot alter the address p points to unless you assign another address to it.

```go
var p *int
p++
```

2.

Once a value is assigned to a pointer, with the exception of `nil`, Go guarantees that the thing being pointed to will continue to be valid for the lifetime of the pointer. So is totally safe to do in Go. The compiler will arrange for the memory location holding the value of i to be valid after f() returns

```go
func f() *int {
  i := 1
  return &i
}
```

3.

`Nil` pointers. Yes, you can still have nil pointers and panics because of them, however in my experience the general level of hysteria generated by nil pointer errors, and the amount of defensive programming present in other languages like Java is not present in Go.

multiple return values, nil is not used as a sentinel for something went wrong. Obviously this leaves the question of programmers not checking their errors, but this is simply a matter of education.

Strings are value types, not pointers, which is the, IMO, the number one cause of null pointer exceptions in languages like Java and C++.

`var s string // the zero value of s is "", not nil`

In fact, most of the built in data types, maps, slices, channels, and arrays, have a sensible default if they are left uninitialized. Thanks to Dustin Sallings for pointing this out.
