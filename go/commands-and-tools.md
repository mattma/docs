
- Go building binaries for different system
- Setup IDE


## Go building binaries for different system

1. it has to have a GOROOT variable setup

2. make sure that your username is owning the GOROOT directory

`sudo chown -R mma $GOROOT`

```bash
cd $GOROOT/src

# 386 arch works both window and linux
export GOARCH=386

# build this for window.
export GOOS=windows

# build this for linux
export GOOS=linux
```

To build any app in windows

```bash
# build this app for window.
GOOS=windows GOARCH=386 go build -o hello.exe

# build this app for linux
GOOS=linux GOARCH=386 go build -o hello-linux

# build this app for mac
go build -o hello-mac
```

## Go commands

```bash
# To run the program, print the output in the console
go run hello.go

# To build the program into binary in the same folder
go build hello.go

# To build the program into binary, put it inside $GOPATH/bin
go install
```

```bash
# omit the filename of the source code file that we
# want to build and the go tool will default to the current package:
go build

# package can also be specified directly:
go build github.com/goinaction/code/chapter3/wordcount

# Instead of a package specifier, we can also use a path shortcut as an argument to most
#/ of the go commands
go build wordcount.go
# or
go build .
```

#### godoc

Generate documentation. It reads documentation directly from Go source files. Keep docs and code in sync when they live together in the same place.

Just write the documentation above the source code itself and `godoc` will extract it along with the code to generate the necessary documentation.

```bash
# dodoc packageName funcName, show the description of that function
godoc cmd/fmt Println
godoc cmd/time Now
```

- Web view

we can use godoc program to start a web server
with a clickable index of Go packages. The godoc web server gives us a fully navigable
web version of the documentation for all the Go source code installed in our system. `godoc -http=:6060`

- our own code comment

it will automatically include our
comments in the Go documentation generated by godoc.
Comments can be started
using either two slashes, or using the slash asterisk style.

```go
/*
This package documentation will be shown before any type or function
documentation is displayed for our package.
...
*/
package usb

// Retrieve connects to the configuration repository and gathers
// various connection settings, usernames, passwords. It returns a
// config struct on success, or an error.
func Retrieve() (config, error) {
// ... omitted
}
```

#### go get

It fetches the github source code and put it into `$GOPATH`, then build the binary.
Note: Repo name must be the same of the folder name and binary name.

```bash
go get github.com/mattma/reddit
```

#### go build

compile it once and save the compiled result for later use, so creates an executable binary file.

- look at some compiler’s optimizations

```bash
# Build your file (here called t.go) passing some gcflags
go build -gcflags=-m t.go
```

- Set the build id using git's SHA

```bash
# get the short version of SHA1 of your latest commit
git rev-parse --short HEAD
```

```go
// example.go
package main

import "fmt"

// compile passing -ldflags "-X main.Build <build sha1>"
var Build string

func main() {
  fmt.Printf("Using build: %s\n", Build)
}
```

```bash
go build -ldflags "-X main.Build a1064bc" example.go

./example  # Using build: a1064bc
```

#### go install

To run current go program to bin directory

Executing this go install command will fetch, build, and install the code coverage
package. Code coverage, not available prior to this installation is now available on tests.

```bash
$ go install code.google.com/p/go.tools/cmd/cover
```

#### go list

list packages

```bash
# To see what packages my app imports without standard packages
go list -f '{{join .Deps "\n"}}' | xargs go list -f '{{if not .Standard}}{{.ImportPath}}{{end}}'

# the list to also contain standard packages
go list -f '{{join .Deps "\n"}}' |  xargs go list -f '{{.ImportPath}}'
```

#### go clean

CLean removes object files from package source directories. Executable program is gone.
ex: `go clean hello.go`


#### go vet

it will check our code for common errors.

the types of errors vet can catch:

* Bad parameters in Printf-style function calls
* Method signature errors for common method definitions
* Bad struct tags
* Unkeyed composite literals

#### go fmt

apply and format a predetermined layout to Go source code. type `go fmt` followed by a file or package specification.
The fmt command will automatically format the source code files we specify and save
them

Running the
go fmt command from the root of a package will cause Go to go through each of the .go files
in a package and rewrite them into the canonical style. The go fmt command can have a path
to a package or ./... (iterate over all sub-directories) appended to it.

#### go test

The Go testing
tool will only look at files that end in `_test.go`. Once the
testing tool finds a testing file, it then looks for testing functions to run.

the package name also ends with _test. When
the package name ends like this, the test code can only access exported identifiers.
This is true even if the test code file is in the same folder as the code being tested.


If the verbose option
(-v) isn’t used when calling `go test`, we won’t see any test output (t.Logf, etc) unless the test fails.

```go
// ExampleSendJSON provides a basic example.
func TestSendJSON() {
}
```

The -run option
takes any regular expression to filter the test functions to run. It works with both unit
tests and example functions.

```bash
# -v means provide verbose output,
go test -v

# the specific function TestSendJSON is specified with the -run option
go test -v -run="TestSendJSON"
```

we specified the -run option passing the string "none" to make
sure no unit tests are run prior to running the specified benchmark function. Both of
these options take a regular expression to filter the tests to run. Since there’s no unit
test function that has none in its name, none eliminates any unit tests from running.

After the word PASS, you see the result of running
the benchmark function. The first number, 5000000, represents the number of
times the code inside the loop was executed. In this case, that’s five million times. The
next number represents the performance of the code based on the number of nanoseconds
per operation, so using the Sprintf function in this context takes 258 nanoseconds
on average per call.

The final output from running the benchmark shows ok to represent the benchmark
finished properly. Then the name of the code file that was executed is displayed,
and finally, the total time the benchmark ran. The default minimum run time for a
benchmark is 1 second. You can see how the framework still ran the test for approximately
a second and a half. You can use another option called -benchtime if you want
to have the test run longer. Let’s run the test again using a bench time of three seconds
(see figure 9.15)

```bash
# only run benchmark test
go test -v -run="none" -bench="BenchmarkSprintf"
```

This time with the output you see two new values: a value for B/op and one for
allocs/op. The allocs/op value represents the number of heap allocations per operation.
You can see the Sprintf functions allocate two values on the heap per operation,
and the other two functions allocate one value per operation. The B/op value
represents the number of bytes per operation. You can see that those two allocations
from the Sprintf function result in 16 bytes of memory being allocated per operation.
The other two functions only allocated 2 bytes per operation.

```bash
# -benchmem, will provide information about the number of allocations and bytes per allocation for a given test.
go test -v -run="none" -bench=. -benchtime="3s" -benchmem
```

CODE COVERAGE, code.google.com/p/go.tools/cmd/cover

http://blog.golang.org/cover  more info about cover tool

```bash
go test -cover
```

#### go doc

There’s one rule you need to follow with examples. An example is always based on
an existing exported function or method. If you don’t use the name of an existing
function or method, the test won’t show in the Go documentation for the package.

The code you write for an example is to show someone how to use the specific function
or method.

The Output: marker is used to document the output you expect to have after the
test function is run. The testing framework knows how to compare the final output from stdout against this output comment. If everything matches, the test passes, and
you have an example that works inside the Go documentation for the package. If the
output doesn’t match, the test fails.

If you start a local godoc server (godoc -http=":3000") and navigate to the
handlers package, you can see this all come together.


```go
// ExampleSendJSON provides a basic example.
func ExampleSendJSON() {
}
```

## Popular tools

`Goimports` is a tool that updates your Go import lines, adding missing ones and removing unreferenced ones.
It acts the same as `gofmt` (drop-in replacement) but in addition to code formatting, also fixes imports.

#### Godep

solved the dependency problem by
using a technique called vendoring and import path re-writing. The idea is to copy all the
dependencies into a directory inside the project repo. Then to re-write any import paths
that reference those dependencies by providing the location inside the project itself

godep created a directory called `Godeps`.
The source code for the dependencies that the tooling vendored are located inside another
set of directories called `_workspace/src`.

```go
// Before vendoring
// used the canonical path for the package.
package main
import (
    "bitbucket.org/ww/goautoneg"
    "github.com/beorn7/perks"
)

// After vendoring
// reference the packages which are now physically located on disk inside the project itself.
package main
import (
    "github.ardanstudios.com/myproject/Godeps/_workspace/src/bitbucket.org/ww/goautoneg"
    "github.ardanstudios.com/myproject/Godeps/_workspace/src/github.com/beorn7/perks"
)
```

#### [gb](getgb.io)

gb is a whole new class of build tool being developed by members of the Go community. It is not compatible with GoTool.

#### cgo

C + Go = cgo
Go provides support for binding C libraries to Go programs. Go provides a library of C compatibility
tools. This library eases the transition between, for example, C-style strings and Go strings.
Furthermore, the Go tools can build mixed C and Go programs. Go also has support for SWIG
wrappers. You can get a feel for the features by running godoc c and reading the brief overview.

## Setup IDE

To setup [GoSublime](https://github.com/DisposaBoy/GoSublime#features)http://www.wolfe.id.au/2015/03/05/using-sublime-text-for-go-development/

* Install package "GoSublime"
* Install Go dependencies

```bash
go get -u github.com/nsf/gocode
go get -u golang.org/x/tools/cmd/goimports
go get -u golang.org/x/tools/cmd/vet
go get -u golang.org/x/tools/cmd/oracle
go get -u golang.org/x/tools/cmd/godoc
```

* `Preferences->Package Settings->GoSublime->Settings-User`

```
{
    // you may set specific environment variables here
    // e.g "env": { "PATH": "$HOME/go/bin:$PATH" }
    // in values, $PATH and ${PATH} are replaced with
    // the corresponding environment(PATH) variable, if it exists.
    "env": {"GOPATH": "$HOME/Code/go", "PATH": "$GOPATH/bin:$PATH" },

    "fmt_cmd": ["goimports"],

    // enable comp-lint, this will effectively disable the live linter
    "comp_lint_enabled": true,

    // list of commands to run
    "comp_lint_commands": [
        // run `golint` on all files in the package
        // "shell":true is required in order to run the command through your shell (to expand `*.go`)
        // also see: the documentation for the `shell` setting in the default settings file ctrl+dot,ctrl+4
        {"cmd": ["golint *.go"], "shell": true},

        // run go vet on the package
        {"cmd": ["go", "vet"]},

        // run `go install` on the package. GOBIN is set,
        // so `main` packages shouldn't result in the installation of a binary
        {"cmd": ["go", "install"]}
    ],

    "on_save": [
        // run comp-lint when you save,
        // naturally, you can also bind this command `gs_comp_lint`
        // to a key binding if you want
        {"cmd": "gs_comp_lint"}
    ]
}
```
